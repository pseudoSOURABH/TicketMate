{"ast":null,"code":"/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\nfunction getAxisMap(element, _ref, _ref2) {\n  let {\n    x,\n    y\n  } = _ref;\n  let {\n    xAxisID,\n    yAxisID\n  } = _ref2;\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {\n      axisId: xAxisID\n    };\n  });\n  each(y, key => {\n    axisMap[key] = {\n      axisId: yAxisID\n    };\n  });\n  return axisMap;\n}\nconst cancelAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n  return window.cancelAnimationFrame;\n}();\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? {\n    value: scale.getPixelForValue(value),\n    transitionable: true\n  } : {\n    value: fallback\n  };\n}\nfunction updateBoxAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {\n        axisId: xScaleID\n      };\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {\n        axisId: xScaleID\n      };\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {\n        axisId: xScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {\n        axisId: yScaleID\n      };\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {\n        axisId: yScaleID\n      };\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {\n        axisId: yScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n}\nfunction updateLineAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    scaleID,\n    value\n  } = options;\n  const scale = scales[scaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {\n        axisId: scaleID\n      };\n      streaming[isHorizontal ? 'x2' : 'y2'] = {\n        axisId: scaleID\n      };\n    }\n    return isHorizontal ? {\n      top,\n      bottom\n    } : {\n      left,\n      right\n    };\n  }\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n    if (min.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.left = left;\n    }\n    if (max.transitionable) {\n      streaming.x2 = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.right = right;\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n    if (min.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.top = top;\n    }\n    if (max.transitionable) {\n      streaming.y2 = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n  return clip;\n}\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {\n    xScaleID,\n    yScaleID,\n    xValue,\n    yValue\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n    if (x.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    }\n  }\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n    if (y.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    }\n  }\n}\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n  BoxAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n  LineAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n  PointAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n      afterUpdate.call(this, _chart, args, options);\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n  if (plugin) {\n    const state = plugin._getState(chart);\n    return state && state.elements || [];\n  }\n  return [];\n}\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\nconst transitionKeys$1 = {\n  x: ['x', 'caretX'],\n  y: ['y', 'caretY']\n};\nfunction update$1() {\n  const me = this;\n  const element = me.getActiveElements()[0];\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  me.constructor.prototype.update.call(me, ...args);\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleOptions: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction storeOriginalScaleOptions(chart) {\n  const {\n    originalScaleOptions\n  } = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDuration = 0,\n    maxDuration = Infinity,\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\nfunction panRealTimeScale(scale, delta, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n    streaming.zoomPlugin = plugin;\n  }\n}\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {\n    size: milliseconds,\n    steps\n  } = INTERVALS[unit];\n  let factor;\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n  return factor;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {\n      common,\n      size,\n      steps\n    } = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nconst datasetPropertyKeys = ['pointBackgroundColor', 'pointBorderColor', 'pointBorderWidth', 'pointRadius', 'pointRotation', 'pointStyle', 'pointHitRadius', 'pointHoverBackgroundColor', 'pointHoverBorderColor', 'pointHoverBorderWidth', 'pointHoverRadius', 'backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'radius', 'rotation'];\nfunction clean(scale) {\n  const {\n    chart,\n    id,\n    max\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n      count = i - start;\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\nfunction scroll(scale) {\n  const {\n    chart,\n    id,\n    $realtime: realtime\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {\n      data: elements = [],\n      dataset: element\n    } = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {\n      $realtime: realtime,\n      options\n    } = me;\n    const {\n      bounds,\n      offset,\n      ticks: ticksOpts\n    } = options;\n    const {\n      autoSkip,\n      source,\n      major: majorTicksOpts\n    } = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n        return resolveOption(me, 'frameRate');\n      });\n    }\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n      me._handleMargins();\n    }\n  }\n  draw(chartArea) {\n    const me = this;\n    const {\n      chart,\n      ctx\n    } = me;\n    const area = me.isHorizontal() ? {\n      left: chartArea.left,\n      top: 0,\n      right: chartArea.right,\n      bottom: chart.height\n    } : {\n      left: 0,\n      top: chartArea.top,\n      right: chart.width,\n      bottom: chartArea.bottom\n    };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const capacity = me._getLabelCapacity(min);\n    const {\n      time: timeOpts,\n      ticks: ticksOpts\n    } = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    time = first;\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n}\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\nvar version = \"2.0.0\";\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {\n  x: ['x', 'cp1x', 'cp2x'],\n  y: ['y', 'cp1y', 'cp2y']\n};\nfunction update(mode) {\n  const me = this;\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n      controller._setStyle = function (element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n  Chart.prototype.update.call(me, mode);\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {\n      render\n    };\n    const canvas = streaming.canvas = chart.canvas;\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n  afterInit(chart) {\n    chart.update = update;\n  },\n  beforeUpdate(chart) {\n    const {\n      scales,\n      elements\n    } = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, _ref3 => {\n      let {\n        type\n      } = _ref3;\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n  beforeDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    if (mode === 'quiet') {\n      const {\n        controller,\n        $animations\n      } = meta;\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n  afterDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    const {\n      data: elements = [],\n      dataset: element,\n      controller\n    } = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n  beforeDatasetDraw(chart, args) {\n    const {\n      ctx,\n      chartArea,\n      width,\n      height\n    } = chart;\n    const {\n      xAxisID,\n      yAxisID,\n      controller\n    } = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n    clipArea(ctx, area);\n  },\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n  destroy(chart) {\n    const {\n      scales,\n      $streaming: streaming,\n      tooltip\n    } = chart;\n    const {\n      canvas,\n      mouseEventListener\n    } = streaming;\n    delete chart.update;\n    if (tooltip) {\n      delete tooltip.update;\n    }\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\nconst registerables = [StreamingPlugin, RealTimeScale];\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };","map":{"version":3,"names":["registry","TimeScale","defaults","DatasetController","Chart","valueOrDefault","each","requestAnimFrame","callback","noop","isFinite","clipArea","unclipArea","isNumber","_lookup","isArray","getRelativePosition","clamp","value","lower","upper","Math","min","max","resolveOption","scale","key","realtimeOpts","options","realtime","streamingOpts","chart","plugins","streaming","getAxisMap","element","_ref","_ref2","x","y","xAxisID","yAxisID","axisMap","axisId","cancelAnimFrame","window","cancelAnimationFrame","startFrameRefreshTimer","context","func","frameRequestID","refresh","nextRefresh","now","Date","newFrameRate","frameDuration","newNextRefresh","call","stopFrameRefreshTimer","stopDataRefreshTimer","refreshTimerID","clearInterval","refreshInterval","startDataRefreshTimer","interval","setInterval","newInterval","isNaN","scaleValue","fallback","parse","getPixelForValue","transitionable","updateBoxAnnotation","scales","chartArea","xScaleID","yScaleID","xMin","xMax","yMin","yMax","xScale","yScale","top","left","bottom","right","$streaming","reverse","width","height","updateLineAnnotation","scaleID","isHorizontal","pixel","clip","x2","y2","updatePointAnnotation","xValue","yValue","initAnnotationPlugin","BoxAnnotation","getElement","LineAnnotation","PointAnnotation","resolveBoxAnnotationProperties","prototype","resolveElementProperties","resolveLineAnnotationProperties","resolvePointAnnotationProperties","properties","attachChart$1","plugin","annotationPlugin","afterUpdate","_chart","args","mode","animationOpts","animation","getElements","state","_getState","elements","detachChart$1","transitionKeys$1","update$1","me","getActiveElements","meta","getDatasetMeta","datasetIndex","_len","arguments","length","Array","_key","constructor","update","chartStates","WeakMap","getState","get","originalScaleOptions","set","removeState","delete","storeOriginalScaleOptions","id","duration","delay","opt","zoomRealTimeScale","zoom","center","limits","axis","minDuration","maxDuration","Infinity","minDelay","maxDelay","newDuration","maxPercent","newDelay","panRealTimeScale","delta","getValueForPixel","resetRealTimeScaleOptions","realtimeOptions","original","initZoomPlugin","zoomFunctions","panFunctions","attachChart","zoomPlugin","resetZoom","transition","detachChart","INTERVALS","millisecond","common","size","steps","second","minute","hour","day","week","month","quarter","year","UNITS","Object","keys","determineStepSize","unit","capacity","range","milliseconds","factor","ceil","i","ilen","determineUnitForAutoTicks","minUnit","indexOf","Number","MAX_SAFE_INTEGER","determineMajorUnit","addTick","ticks","time","timestamps","lo","hi","timestamp","datasetPropertyKeys","clean","ttl","pause","start","count","removalRange","data","datasets","dataset","controller","point","getParsed","splice","datalabels","_active","item","index","labels","translate","animations","$animations","_from","_to","scroll","$realtime","tooltip","annotations","offset","head","_path","RealTimeScale","props","init","scaleOpts","opts","onRefresh","maxWidth","maxHeight","margins","bounds","ticksOpts","autoSkip","source","major","majorTicksOpts","majorEnabled","enabled","render","undefined","buildTicks","maxArray","minArray","defineProperty","shift","calculateLabelRotation","maxRotation","minRotation","fit","display","paddingLeft","paddingRight","_handleMargins","draw","ctx","area","_gridLineItems","_labelItems","destroy","_generate","adapter","_adapter","_getLabelCapacity","timeOpts","minor","stepSize","weekday","isoWeekday","majorTicksEnabled","hasWeekday","first","startOf","diff","Error","round","add","getDataTimestamps","sort","a","b","map","adapters","parser","displayFormats","describe","_scriptable","name","version","quiet","transitionKeys","_setStyle","_mode","active","lastMouseEvent","setTimeout","_eventHandler","StreamingPlugin","beforeInit","canvas","mouseEventListener","event","pos","type","native","addEventListener","afterInit","beforeUpdate","_ref3","line","capBezierPoints","getPlugin","e","beforeDatasetUpdate","visible","updateElement","updateSharedOptions","afterDatasetUpdate","beforeDatasetDraw","getScaleForId","afterDatasetDraw","beforeEvent","removeEventListener","frameRate","descriptors","registerables"],"sources":["C:/Persist_Task/node_modules/chartjs-plugin-streaming/dist/chartjs-plugin-streaming.esm.js"],"sourcesContent":["/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\nfunction getAxisMap(element, {x, y}, {xAxisID, yAxisID}) {\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {axisId: xAxisID};\n  });\n  each(y, key => {\n    axisMap[key] = {axisId: yAxisID};\n  });\n  return axisMap;\n}\nconst cancelAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n  return window.cancelAnimationFrame;\n}());\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ?\n    {value: scale.getPixelForValue(value), transitionable: true} :\n    {value: fallback};\n}\nfunction updateBoxAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {axisId: xScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {axisId: xScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {axisId: xScaleID, reverse: min.transitionable};\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {axisId: yScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {axisId: yScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {axisId: yScaleID, reverse: min.transitionable};\n    }\n  }\n}\nfunction updateLineAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {scaleID, value} = options;\n  const scale = scales[scaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {axisId: scaleID};\n      streaming[isHorizontal ? 'x2' : 'y2'] = {axisId: scaleID};\n    }\n    return isHorizontal ? {top, bottom} : {left, right};\n  }\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n    if (min.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    } else {\n      clip.left = left;\n    }\n    if (max.transitionable) {\n      streaming.x2 = {axisId: xScaleID};\n    } else {\n      clip.right = right;\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n    if (min.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    } else {\n      clip.top = top;\n    }\n    if (max.transitionable) {\n      streaming.y2 = {axisId: yScaleID};\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n  return clip;\n}\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {xScaleID, yScaleID, xValue, yValue} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n    if (x.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    }\n  }\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n    if (y.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    }\n  }\n}\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n  BoxAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n  LineAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n  PointAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n      afterUpdate.call(this, _chart, args, options);\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n  if (plugin) {\n    const state = plugin._getState(chart);\n    return state && state.elements || [];\n  }\n  return [];\n}\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {x: ['x', 'caretX'], y: ['y', 'caretY']};\nfunction update$1(...args) {\n  const me = this;\n  const element = me.getActiveElements()[0];\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {originalScaleOptions: {}};\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction storeOriginalScaleOptions(chart) {\n  const {originalScaleOptions} = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {chart, axis} = scale;\n  const {minDuration = 0, maxDuration = Infinity, minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\nfunction panRealTimeScale(scale, delta, limits) {\n  const {chart, axis} = scale;\n  const {minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n    streaming.zoomPlugin = plugin;\n  }\n}\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {size: milliseconds, steps} = INTERVALS[unit];\n  let factor;\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n  return factor;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {common, size, steps} = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nconst datasetPropertyKeys = [\n  'pointBackgroundColor',\n  'pointBorderColor',\n  'pointBorderWidth',\n  'pointRadius',\n  'pointRotation',\n  'pointStyle',\n  'pointHitRadius',\n  'pointHoverBackgroundColor',\n  'pointHoverBorderColor',\n  'pointHoverBorderWidth',\n  'pointHoverRadius',\n  'backgroundColor',\n  'borderColor',\n  'borderSkipped',\n  'borderWidth',\n  'hoverBackgroundColor',\n  'hoverBorderColor',\n  'hoverBorderWidth',\n  'hoverRadius',\n  'hitRadius',\n  'radius',\n  'rotation'\n];\nfunction clean(scale) {\n  const {chart, id, max} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n      count = i - start;\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\nfunction scroll(scale) {\n  const {chart, id, $realtime: realtime} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {data: elements = [], dataset: element} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {$realtime: realtime, options} = me;\n    const {bounds, offset, ticks: ticksOpts} = options;\n    const {autoSkip, source, major: majorTicksOpts} = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n        return resolveOption(me, 'frameRate');\n      });\n    }\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n      me._handleMargins();\n    }\n  }\n  draw(chartArea) {\n    const me = this;\n    const {chart, ctx} = me;\n    const area = me.isHorizontal() ?\n      {\n        left: chartArea.left,\n        top: 0,\n        right: chartArea.right,\n        bottom: chart.height\n      } : {\n        left: 0,\n        top: chartArea.top,\n        right: chart.width,\n        bottom: chartArea.bottom\n      };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const capacity = me._getLabelCapacity(min);\n    const {time: timeOpts, ticks: ticksOpts} = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    time = first;\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n}\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\n\nvar version = \"2.0.0\";\n\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {x: ['x', 'cp1x', 'cp2x'], y: ['y', 'cp1y', 'cp2y']};\nfunction update(mode) {\n  const me = this;\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n      controller._setStyle = function(element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n  Chart.prototype.update.call(me, mode);\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {render};\n    const canvas = streaming.canvas = chart.canvas;\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n  afterInit(chart) {\n    chart.update = update;\n  },\n  beforeUpdate(chart) {\n    const {scales, elements} = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, ({type}) => {\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n  beforeDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    if (mode === 'quiet') {\n      const {controller, $animations} = meta;\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n  afterDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    const {data: elements = [], dataset: element, controller} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n  beforeDatasetDraw(chart, args) {\n    const {ctx, chartArea, width, height} = chart;\n    const {xAxisID, yAxisID, controller} = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n    clipArea(ctx, area);\n  },\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n  destroy(chart) {\n    const {scales, $streaming: streaming, tooltip} = chart;\n    const {canvas, mouseEventListener} = streaming;\n    delete chart.update;\n    if (tooltip) {\n      delete tooltip.update;\n    }\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\n\nconst registerables = [StreamingPlugin, RealTimeScale];\n\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}